# -*- coding: utf-8 -*-
"""Assignment1_13thFeb.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1hqxgAZ0ipEaY3Jby3G7MViyPZve0na_4
"""

import numpy as np
import pandas as pd
import random

def sigmoid(x):
    return 1 / (1 + np.exp(-x))

def sigmoid_derivative(z):
  return z*(1 - z)

def defParameter(n , hid, out):
  W1 = np.random.rand(n,hid)
  W2 = np.random.rand(hid,out)
  b1 = np.zeros((1,hid))
  b2 = np.zeros((1,out))
  return W1, W2, b1, b2

def splitData(X, y):
    np.random.seed(42)
    arr_rand = np.random.rand(X.shape[0])
    split = arr_rand < np.percentile(arr_rand, 80)

    X_train = X[split]
    y_train = y[split]
    X_test =  X[~split]
    y_test = y[~split]

    return X_train, y_train, X_test, y_test

def updateParameter(W1, W2, b1, b2, b, lr):
  W1 = W1 - lr*b["dW1"]
  W2 = W2 - lr*b["dW2"]
  b1 = b1 - lr*b["db1"]
  b2 = b2 - lr*b["db2"]
  return W1, W2, b1, b2

def forwardPass(W1, W2, b1, b2, X):
  v = {}
  v["neth1"] = np.dot(X, W1) + b1
  v["H1"] = sigmoid(v["neth1"])
  v["neto1"] = np.dot(v["H1"], W2) + b2
  v["O1"] = sigmoid(v["neto1"])
  return v

def backwardPass(W2, b2, X, Y, v):
  d = {}

  d["dd1"] = v["O1"] - Y
  d["dW2"] = np.dot(v["H1"].T, d["dd1"])
  d["db2"] = np.sum(d["dd1"])
  d["dd2"] = np.dot(d["dd1"], W2.T) * sigmoid_derivative(v["H1"])
  d["db1"] = np.sum(d["dd2"])
  d["dW1"] = np.dot(X.T, d["dd2"])
  return d

def compute_metric(target, pred):
  # TP = []
  # FP = []
  # FN = []
  # TN = []
  # acc = 0
  # P = 0
  # R = 0
  # F1 = 0
  # #acc = np.sum(target == pred)*100/len(target)
  # for i in range(len(target)):
  #   if pred[i] == 1 and target[i] == 1:
  #     TP.append(1)
  #   elif pred[i] == 1 and target[i] == 0:
  #     FP.append(1)
  #   elif pred[i] == 0 and target[i]==1:
  #     FN.append(1)

  # if (sum(TP)+sum(FP)) == 0 or (sum(TP)+sum(FN)) ==0:
  #   acc = np.sum(target == pred)*100/len(target)
  # else:
  #   P = sum(TP)/(sum(TP)+sum(FP))
  #   R = sum(TP)/(sum(TP)+sum(FN))
  #   F1 = (2*P*R)/(P+R)

  acc = np.sum(target == pred)*100/len(target)
  return acc

def predict(W1, W2, b1, b2, input):
  neth1 = np.dot(input, W1) + b1
  H1 = sigmoid(neth1)
  neto1 = np.dot(H1, W2) + b2
  O1 = sigmoid(neto1)
  p = O1 > 0.5
  return p.astype(int)

def model(n, hid, out, iter, X, Y, lr):
  param = {}
  W1, W2, b1, b2 = defParameter(n, hid, out)
  X_train, Y_train, X_valid, Y_valid = splitData(X, Y)
  for i in range(iter):
    # for i in range(X_train.shape[0]):
       f = forwardPass(W1, W2, b1, b2, X_train)
       b = backwardPass(W2, b2, X_train, Y_train, f)
       W1, W2, b1, b2 = updateParameter(W1, W2, b1, b2, b, lr)
  prediction = predict(W1, W2, b1, b2, X_valid)
  acc = compute_metric(Y_valid, prediction)
  print(np.sum(prediction))
  print("Accuracy: ", acc)
  param["W1"] = W1
  param["W2"] = W2
  param["b1"] = b1
  param["b2"] = b2
  return param

def dataloading(data, k):
  data_list = np.empty((1,11))
  for i in range(data.shape[0]):
    if(data[i, 10] == 1):
      if(i == 0):
        data_list = np.concatenate((data_list, data[i:k,:]))
      elif(i == data.shape[0]-1):
        data_list = np.concatenate((data_list, data[-k:, :]))
      else:
        data_list = np.concatenate((data_list, data[i-int(k/2):i+int(k/2),:]))
  return data_list

def dataloading1(data, k, w = 1):
  class1 = [data[i,:] for i in range(data.shape[0]) if data[i,10:11] == 1]
  class1 = np.array(class1)
  for j in range(class1.shape[0]):
    class1 = w*class1
  class0 = [data[i,:] for i in range(data.shape[0]) if data[i,10:11] == 0]
  class0 = np.array(class0)
  class1_count = int(class1.shape[0]/k)
  class0_count = int(class0.shape[0]/k)

  block = {}
  j = 0
  k = 0
  for i in range(0,4):
    block[i] = np.concatenate((class1[j : j + class1_count, :], class0[k: k + class0_count, :]))
    print(block[i].shape)
    j = j + class1_count
    k = k + class0_count
  return block

def model1(n, hid, out, iter, X, Y, lr):
  param = {}
  X_train = X
  X_valid = X
  Y_train = Y
  Y_valid = Y
  acc_1 = {}
  acc = 0
  #prediction={}
  # X_train, Y_train, X_valid, Y_valid = splitData(X, Y)
  train = np.concatenate((X_train, Y_train), axis = 1)
  x_t = dataloading4(train, k = 4)
  # train = dataloading(train, k = 50)
  all_param = {}
  for i in range(0,4):
    W1, W2, b1, b2 = defParameter(n, hid, out)
    for j in range(iter):
      for k in range(0,3):
          # print(int((i+k+1)%4))
          f = forwardPass(W1, W2, b1, b2, x_t[int((i+k+1)%4)][:,:10])
          b = backwardPass(W2, b2, x_t[int((i+k+1)%4)][:,:10], x_t[int((i+k+1)%4)][:,10:11], f)
          W1, W2, b1, b2 = updateParameter(W1, W2, b1, b2, b, lr)
    all_param["Param" + str(i)] = [W1, W2, b1, b2]
    prediction = predict(W1, W2, b1, b2, x_t[i][:,:10])
    acc_1[i] = compute_metric(x_t[i][:,10:11], prediction)
    print(np.sum(prediction))
    print("Hold out Accuracy: ", acc_1[i])
    # all_param["Param" + str(i)] = [W1, W2, b1, b2]
  prediction = predict(W1, W2, b1, b2, X_valid)
  acc = compute_metric(Y_valid, prediction)
  print(np.sum(prediction))
  print("Whole dataset Accuracy: ", acc)


  param["W1"] = W1
  param["W2"] = W2
  param["b1"] = b1
  param["b2"] = b2
  return param, all_param, acc_1, acc

def dataloading4(data, k, w = 1):
  class1_count = int(data.shape[0]/k)

  block = {}
  j = 0
  k = 0
  for i in range(0,4):
    block[i] = data[j : j + class1_count, :]
    print(np.sum(block[i][:,10:11] == 1))
    print(block[i].shape)
    j = j + class1_count
  return block

def model2(n, hid, out, iter, X, Y, lr):
  param = {}
  W1, W2, b1, b2 = defParameter(n, hid, out)
  X_train, Y_train, X_valid, Y_valid = splitData(X, Y)
  for i in range(iter):
    # for i in range(X_train.shape[0]):
       f = forwardPass(W1, W2, b1, b2, X_train)
       b = backwardPass(W2, b2, X_train, Y_train, f)
       W1, W2, b1, b2 = updateParameter(W1, W2, b1, b2, b, lr)
  prediction = predict(W1, W2, b1, b2, X_valid)
  acc = compute_metric(Y_valid, prediction)
  print(np.sum(prediction))
  print("Accuracy: ", acc)
  param["W1"] = W1
  param["W2"] = W2
  param["b1"] = b1
  param["b2"] = b2
  return param

# from IPython.display import Image
# Image('Screenshot_2024-02-13_232956.png', width=400, height =400)

df = pd.read_csv('Dataset_Pal.csv')
df = df.apply(pd.to_numeric)
data = df.to_numpy(dtype=float)
print(data.shape)

np.random.seed(1)   #0.000042    #epoch 2  #0.000085 #epoch 1
lr = 0.1

X = data[:, :10]
y = data[:, 10:11]
param, all_param, acc_1, acc  = model1(10,2,1,10000,X,y, lr)

#param

df = pd.read_csv('Dataset_Pal.csv')
df = df.apply(pd.to_numeric)
data = df.to_numpy(dtype=float)
print(data.shape)

np.random.seed(1)   #0.000042    #epoch 2  #0.000085 #epoch 1
lr = 0.01

X = data[:, :10]
y = data[:, 10:11]
param  = model(10,2,1,100000,X,y, lr)

#param

# W1, W2, b1, b2 = all_p[0]
res = 0
for i in range(data.shape[0]):
  if(data[i,10:11] == 1):
    res += predict(param["W1"], param["W2"], param["b1"], param["b2"], data[i,:10])
print(res)

input1 = np.array([[1,0,0,0,0,0,0,0,0,1]])

k = predict(param["W1"], param["W2"], param["b1"], param["b2"], input1)

# if k == 1:
#   print('Palindrome')
# else:
#   print('Not Palindrome')

# print(acc_1)
# print(acc)

input1 = 0

#inp = input("Enter 10 digit input: ")

# taking input from the user
#inp = input("Enter 10 digit input: ")
#inp = np.array([int(digit) for digit in inp])

#inp = inp.reshape(1, 10)
# k = predict(param["W1"], param["W2"], param["b1"], param["b2"], inp)

# if k == 1:
#   print('Class1, Palindrome')
# else:
#   print('Class0, Not Palindrome')

import pickle
import streamlit

# with open('palindrome.pkl', 'wb') as f:  # open a text file
#     pickle.dump(model1, f)

with open('parameters.pkl', 'wb') as f:  # open a text file
    pickle.dump(param, f)

with open('all_parameters.pkl', 'wb') as f:  # open a text file
    pickle.dump(all_param, f)

#pip install streamlit

import streamlit as st
st.title('Assignment_1')

#!streamlit run /content/assignment1_13thfeb1.py

st.image('Screenshot_2024-02-13_232956.png', caption='Neural Network Architecture')

for i in range(4):
  st.write(i+1, " fold accuracy (#inputs = 256): ", acc_1[i])

st.write("Whole dataset accuracy (#inputs = 1024): ", acc)

st.write("Following results are final weights and biases")
st.write(param)

#num = st.number_input('Insert a number: ')
#st.write('Input ', num)
#num = str(int(num))
#l = np.array([[1,0,0,0,0,0,0,0,0,1]])
#inp = np.array([int(digit) for digit in num])
#inp1 = l
#inp1

#inp = inp.reshape(1, 10)
#k = predict(param["W1"], param["W2"], param["b1"], param["b2"], inp)

#if k == 1:
#  st.write('Class1, Palindrome')
#else:
#  st.write('Class0, Not Palindrome')











